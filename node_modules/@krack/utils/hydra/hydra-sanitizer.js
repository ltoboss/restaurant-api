"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const redis_1 = require("redis");
class HydraSanitizer {
    constructor(redisConfig) {
        this.SERVICE_NAME_POSITION = 2;
        this.SERVICE_INSTANCE_POSITION = 3;
        this.TIME_TO_LIVE = 10;
        this.namespace = 'hydra:service';
        this.redisClient = redis_1.createClient(redisConfig);
        this.namespace = 'hydra:service';
        this.redisClient = redis_1.createClient(redisConfig);
        this.keysAsync = util_1.promisify(this.redisClient.keys).bind(this.redisClient);
        this.delAsync = util_1.promisify(this.redisClient.del).bind(this.redisClient);
        this.hdelAsync = util_1.promisify(this.redisClient.hdel).bind(this.redisClient);
        this.hgetallAsync = util_1.promisify(this.redisClient.hgetall).bind(this.redisClient);
    }
    getServiceInstances(serviceName = '*') {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield this.keysAsync(`${this.namespace}:${serviceName}:*`);
            const services = keys.map((redisKeys) => {
                const redisKeysComponents = redisKeys.split(':');
                return redisKeysComponents[this.SERVICE_INSTANCE_POSITION];
            });
            const uniqueServices = [...new Set(services)];
            return uniqueServices;
        });
    }
    getServices(serviceName = '*') {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield this.keysAsync(`${this.namespace}:${serviceName}:*`);
            const services = keys.map((service) => service.split(':')[this.SERVICE_NAME_POSITION]);
            const uniqueServices = [...new Set(services)];
            return uniqueServices;
        });
    }
    getServicePresence(serviceName) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield this.keysAsync(`${this.namespace}:${serviceName}:*:presence`);
            return keys;
        });
    }
    getNodes(serviceName) {
        return __awaiter(this, void 0, void 0, function* () {
            const nodes = yield this.hgetallAsync('hydra:service:nodes');
            const keys = nodes ? Object.keys(nodes) : [];
            let resultNodes = {};
            keys.forEach((key) => {
                resultNodes[key] = JSON.parse(nodes[key]);
                resultNodes[key]['elapsed'] = null;
                Object.defineProperty(resultNodes[key], 'elapsed', {
                    get() {
                        const currentDate = (new Date()).valueOf();
                        const updatedOn = (new Date(this.updatedOn)).valueOf();
                        return (currentDate - updatedOn) / 1000;
                    },
                });
            });
            if (typeof serviceName === 'string') {
                resultNodes = keys.reduce((acc, key) => {
                    if (resultNodes[key].serviceName === serviceName) {
                        acc[key] = resultNodes[key];
                    }
                    return acc;
                }, {});
            }
            return resultNodes;
        });
    }
    removeService(serviceName) {
        return __awaiter(this, void 0, void 0, function* () {
            console.debug('Removing service', serviceName);
            const deleteableKeys = yield this.keysAsync(`${this.namespace}:${serviceName}*`);
            deleteableKeys.forEach((key) => __awaiter(this, void 0, void 0, function* () {
                yield this.delAsync(key);
            }));
            return true;
        });
    }
    redisKeyIsServiceInstanceReference(key) {
        return !!key.match(/^[a-f0-9]{32}$/i);
    }
    removeOldNodes(serviceName) {
        return __awaiter(this, void 0, void 0, function* () {
            const nodes = yield this.getNodes(serviceName);
            const nodeKeys = Object.keys(nodes);
            const preservedNodes = {};
            nodeKeys.forEach((key) => __awaiter(this, void 0, void 0, function* () {
                const node = nodes[key];
                if (node.elapsed > this.TIME_TO_LIVE) {
                    yield this.hdelAsync('hydra:service:nodes', node.instanceID);
                }
                else {
                    preservedNodes[key] = node;
                }
            }));
            return preservedNodes;
        });
    }
    cleanSingleService(serviceName) {
        return __awaiter(this, void 0, void 0, function* () {
            const instances = yield this.getServiceInstances(serviceName);
            const preservedNodes = yield this.removeOldNodes(serviceName);
            const preservedNodesKeys = Object.keys(preservedNodes);
            console.debug('Related redis keys', instances);
            console.debug('Preserve Nodes', serviceName, preservedNodesKeys);
            instances.forEach((instance) => __awaiter(this, void 0, void 0, function* () {
                if (preservedNodesKeys.length === 0 ||
                    (this.redisKeyIsServiceInstanceReference(instance)
                        && !preservedNodesKeys.includes(instance))) {
                    yield this.removeService(`${serviceName}:${instance}`);
                }
            }));
        });
    }
    cleanServices() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.removeOldNodes();
            this.getServices().then((services) => {
                services.forEach((serviceName) => __awaiter(this, void 0, void 0, function* () {
                    yield this.cleanSingleService(serviceName);
                }));
            });
        });
    }
}
exports.HydraSanitizer = HydraSanitizer;
exports.default = HydraSanitizer;
//# sourceMappingURL=hydra-sanitizer.js.map